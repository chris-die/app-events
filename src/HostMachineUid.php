<?php
declare(strict_types=1);

namespace Serato\EventLog;

use Serato\AppEvents\Exception\InvalidHostMachineUidException;

/**
 * ** HostMachineUid **
 *
 * Provides functionality for handling host IDs generated by client software applications.
 *
 * * Host ID format *
 *
 * There are two different host ID formats is use: one that's used by Serato DJ, and another
 * that's used by Serato Studio and Serato Sample.
 *
 * These formats are referred to as `Host ID` and `Host ID Extended` respectively.
 *
 * Some rules that apply to both host ID formats:
 *
 * - System IDs may start with a manufacturer ID. This ID is max. 4 bytes and may contain non-ASCII characters.
 * - Storage IDs are not required. ie. They may be empty (yes, seriously).
 * - Storage IDs are not necessarily unique within a single host ID
 * - Storage IDs contain only ASCII characters
 *
 * Host ID examples of the same host with different storage devices attached as generated by
 * each format:
 *
 * `Host ID` format
 *
 * P57TL8GGQI69~GBFUL623C0UIG                                           # SystemId~StorageId0
 * P57TL8GGQI69~PG796169S564N489                                        # SystemId~StorageId1
 * P57TL8GGQI69~PG796169S564N489~GBFUL623C0UIG                          # SystemId~StorageId1~StorageId0
 * P57TL8GGQI69~GBFUL623C0UIG~PG796169S564N489                          # SystemId~StorageId0~StorageId1
 *
 * `Host ID Extended` format
 *
 * SID=P57TL8GGQI69~GBFUL623C0UIG                                       # SystemId~StorageId0
 * SID=P57TL8GGQI69~PG796169S564N489                                    # SystemId~StorageId1
 * SID=P57TL8GGQI69~GBFUL623C0UIG SID=P57TL8GGQI69~PG796169S564N489     # SystemId~StorageId1 SystemId~StorageId0
 * SID=P57TL8GGQI69~PG796169S564N489 SID=P57TL8GGQI69~GBFUL623C0UIG     # SystemId~StorageId0 SystemId~StorageId1
 */
class HostMachineUid
{
    private const FIELD_DELIMITER = '~';
    private const HOSTIDEXTENDED_SYSTEM_ID_PREFIX = 'SID=';
    public const EMPTY_STORAGEID_PLACEHOLDER = 'EMPTY_STORAGE_ID';

    /** @var string */
    private $str = '';

    /** @var string */
    private $systemId = '';

    /** @var array */
    private $storageIds = [];

    public function __construct(string $hostId)
    {
        $this->str = $hostId;
        $this->parse($hostId);
    }

    public function __toString(): string
    {
        return $this->str;
    }

    /**
     * Compare two host ids and check if they match the comparison policy:
     * - System ID must match
     * - At least one storage ID must match
     *
     * @param self $hostMachineId   HostMachineUid instance to compare against
     *
     * @return bool     Indicates whether the HostMachineUids match
     */
    public function match(self $hostMachineId): bool
    {
        # TODO (maybe)
        #
        # Host software applications and the My Serato window do more than just a straight string
        # comparison on storage IDs: if the storage ID strings don't match they swap bytes within
        # the string and re-compare.
        #
        # I *think* this was a fix for a Windows version that, for whatever reason, generated a
        # different host ID for the same device as a previous version of Windows.
        #
        # This logic is NOT implemented here but could be added later if need be.

        // Confirm that the system IDs match
        if (strcmp($this->getSystemId(), $hostMachineId->getSystemId()) !== 0 ||
            count(array_intersect($this->getStorageIds(), $hostMachineId->getStorageIds())) === 0
        ) {
            return false;
        } else {
            return true;
        }
    }

    /**
     * Returns a new instance
     *
     * @param string $hostId
     * @return self
     */
    public static function create(string $hostId): self
    {
        return new self($hostId);
    }

    /**
     * Parses a host ID
     *
     * @param string $hostId
     * @return void
     */
    private function parse(string $hostId): void
    {
        if (strpos($hostId, self::HOSTIDEXTENDED_SYSTEM_ID_PREFIX) === 0) {
            $this->parseHostIdExtended($hostId);
        } else {
            $this->parseHostId($hostId);
        }
    }

    /**
     * Parses a host ID generated by an application that uses the `Host ID` format
     *
     * @param string $hostId
     * @return void
     *
     * @throws InvalidHostMachineUidException
     */
    private function parseHostId(string $hostId): void
    {
        $this->systemId = '';
        $this->storageIds = [];

        # Host ID cannot start with self::HOSTIDEXTENDED_SYSTEM_ID_PREFIX ("SID=") and
        # must contain at least one self::FIELD_DELIMITER character ("~")
        if (strpos($hostId, self::HOSTIDEXTENDED_SYSTEM_ID_PREFIX) === 0 ||
            count(explode(self::FIELD_DELIMITER, $hostId)) < 2
        ) {
            throw new InvalidHostMachineUidException(
                'Host ID "' . $hostId . '" does not conform to `Host ID` requirements. ' .
                'A `Host ID` cannot start with "' . self::HOSTIDEXTENDED_SYSTEM_ID_PREFIX .
                '" and must contain at one "' . self::FIELD_DELIMITER . '" character.'
            );
        }

        $sections = explode(self::FIELD_DELIMITER, $hostId);
        $this->setSystemId(array_shift($sections));

        foreach ($sections as $section) {
            if ($section === $this->getSystemId()) {
                throw new InvalidHostMachineUidException(
                    'Host ID "' . $hostId . '" does not conform to `Host ID` requirements. ' .
                    'System IDs must be unique within a host ID.'
                );
            } else {
                # Storage ID can legitimately be empty string. In this case the self::match function
                # is expected to match on the emptyness.
                # So store a placeholder string so that represents the missing storage ID.
                if ($section === '' || $section === null) {
                    $section = self::EMPTY_STORAGEID_PLACEHOLDER;
                }

                $this->addStorageId($section);
            }
        }
    }

    /**
     * Parses a host ID generated by an application that uses the `Host ID Extended` format
     *
     * @param string $hostId
     * @return void
     *
     * @throws InvalidHostMachineUidException
     */
    private function parseHostIdExtended(string $hostId): void
    {
        $this->systemId = '';
        $this->storageIds = [];

        # Host ID must start with self::HOSTIDEXTENDED_SYSTEM_ID_PREFIX ("SID=") and
        # must contain at least one self::FIELD_DELIMITER character ("~")
        if (strpos($hostId, self::HOSTIDEXTENDED_SYSTEM_ID_PREFIX) !== 0 ||
            count(explode(self::FIELD_DELIMITER, $hostId)) < 2
        ) {
            throw new InvalidHostMachineUidException(
                'Host ID "' . $hostId . '" does not conform to `Host ID Extended` requirements. ' .
                'A `Host ID Extended` must start with "' . self::HOSTIDEXTENDED_SYSTEM_ID_PREFIX .
                '" and must contain at one "' . self::FIELD_DELIMITER . '" character.'
            );
        }

        foreach (explode(self::HOSTIDEXTENDED_SYSTEM_ID_PREFIX, $hostId) as $section) {
            $section = trim($section);
            if ($section !== '') {
                # Should be an array with two items: [0] = system ID, [1] = storage ID
                $systemStoragePair = explode(self::FIELD_DELIMITER, $section);

                if (count($systemStoragePair) !== 2) {
                    throw new InvalidHostMachineUidException(
                        'Host ID "' . $hostId . '" does not conform to `Host ID Extended` requirements. ' .
                        'Each "' . self::HOSTIDEXTENDED_SYSTEM_ID_PREFIX .
                        '"-delimited section must contain only a single "' .
                        self::FIELD_DELIMITER . '" character denoting a system ID / storage ID pair.'
                    );
                }

                # System ID must the same for every section
                if (!$this->setSystemId($systemStoragePair[0])) {
                    throw new InvalidHostMachineUidException(
                        'Host ID "' . $hostId . '" does not conform to `Host ID Extended` requirements. ' .
                        'Each "' . self::HOSTIDEXTENDED_SYSTEM_ID_PREFIX .
                        '"-delimited system ID / storage ID pair must ' .
                        'have the same system ID.'
                    );
                }

                # Can't have the system ID present where the storage ID should be
                if ($this->getSystemId() === $systemStoragePair[1]) {
                    throw new InvalidHostMachineUidException(
                        'Host ID "' . $hostId . '" does not conform to `Host ID Extended` requirements. ' .
                        'System ID is duplicated in storage ID data section.'
                    );
                }

                # Storage ID can legitimately be empty string. In this case the self::match function
                # is expected to match on the emptyness.
                # So store a placeholder string so that represents the missing storage ID.
                if ($systemStoragePair[1] === '' || $systemStoragePair[1] === null) {
                    $systemStoragePair[1] = self::EMPTY_STORAGEID_PLACEHOLDER;
                }

                $this->addStorageId($systemStoragePair[1]);
            }
        }
    }

    /**
     * Returns the system ID
     *
     * @return string
     */
    public function getSystemId(): string
    {
        return $this->systemId;
    }

    public function getStorageIds(): array
    {
        return $this->storageIds;
    }

    /**
     * Returns a uniform host id to be used by client apps.
     * The format is simple i.e. {SystemId}~{StorageId1}~{StorageID2}....n
     * For No Storage Ids available, the format would be {SystemId}~
     * @return string
     */
    public function getCanonicalHostId(): string
    {
        # GET all storage Ids
        $storageIds = $this->getStorageIds();
        # SORT the storage Ids array in string mode, implode into a string.
        # Concatenate with system Id and return back the updated hostId.
        sort($storageIds, SORT_STRING);
        return $this->systemId . '~' . implode('~', $storageIds);
    }

    /**
     * Sets the system ID.
     *
     * Will return `true` if system ID has not previously been set
     * or is being re-set to the current value.
     *
     * Will return `false` if system ID is currently set and the new
     * value does not match the current value.
     *
     * @param string $systemId
     * @return boolean
     */
    private function setSystemId(string $systemId): bool
    {
        if ($this->systemId === '' || $this->systemId === $systemId) {
            $this->systemId = $systemId;
            return true;
        } else {
            return false;
        }
    }

    /**
     * Adds a storage ID.
     *
     * Returns `true` if the storage ID has not previosly been set, otherwise `false`.
     *
     * @param string $storageId
     * @return boolean
     */
    private function addStorageId(string $storageId): bool
    {
        if (in_array($storageId, $this->storageIds)) {
            return false;
        } else {
            $this->storageIds[] = $storageId;
            return true;
        }
    }
}
